# -*- coding: utf-8 -*-
"""Tbot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RDWNirp-wLEaRactHgMg2XZqrUzD8PLU
"""

import pandas as pd
from telegram import Update
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    ContextTypes, filters
)
import random
import datetime
import asyncio
import threading
import os

# ==========================
# BOT CONFIG
# ==========================
BOT_TOKEN = "8267143715:AAF5Xbk6gf6k6qpWEJBVZAWsl8Mv6xXj-9Q"
ADMIN_USERNAME = "Pr_nag"   # without @
QUESTIONS_FILE = "questions.csv"
RESULTS_FILE = "results.csv"

# ==========================
# LOAD QUESTIONS
# ==========================
questions = pd.read_csv(QUESTIONS_FILE)
rounds = sorted(questions['round'].unique())

# track progress and selfie waiting state
teams = {}  # {user_id: {"round": int, "start_time": time}}
disqualified = set()

awaiting_selfie = {}  # {user_id: {"round": int, "answer": int}}

# ==========================
# SAVE RESULTS
# ==========================
def save_result(user, username, round_num, correct, time_taken, selfie_file_id=None):
    df = pd.DataFrame([{
        "username": username,
        "round": round_num,
        "correct": correct,
        "time_taken_sec": time_taken,
        "timestamp": datetime.datetime.now(),
        "selfie_file_id": selfie_file_id
    }])
    header = not pd.io.common.file_exists(RESULTS_FILE)
    df.to_csv(RESULTS_FILE, mode='a', header=header, index=False)

# ==========================
# START COMMAND
# ==========================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id in disqualified:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="ğŸš« Youâ€™ve been disqualified earlier and cannot restart the quiz."
        )
        
        return
    teams[user.id] = {"round": 1, "start_time": datetime.datetime.now()}
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=f"ğŸ‘‹ Welcome {user.first_name}!.\nGet ready for Round 1!"
    )
    await send_question(update, context)

# ==========================
# SEND QUESTION
# ==========================
async def send_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    round_num = teams[user_id]["round"]

    if round_num > len(rounds):
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="ğŸ‰ All rounds completed! Wait for the final results!"
        )
        return

    # pick random question for rounds 1-5; same for final round
    if round_num < max(rounds):
        qset = questions[questions['round'] == round_num]
        q = qset.sample(1).iloc[0]
    else:
        q = questions[questions['round'] == max(rounds)].iloc[0]

    img = q['image_link']
    ans = int(q['answer'])
    teams[user_id]["answer"] = ans
    teams[user_id]["start_time"] = datetime.datetime.now()

    await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=img,
        caption=f"ğŸ§© Round {round_num}!\nSend your *integer answer* below ğŸ‘‡",
        parse_mode="Markdown"
    )

# ==========================
# HANDLE MESSAGES
# ==========================
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    msg = update.message
    chat_id = update.effective_chat.id

    # if awaiting selfie
    if user.id in awaiting_selfie:
        if msg.photo:
            selfie_file_id = msg.photo[-1].file_id
            round_num = awaiting_selfie[user.id]["round"]
            start_time = teams[user.id]["start_time"]
            time_taken = (datetime.datetime.now() - start_time).total_seconds()

            save_result(user.id, user.username, round_num, True, time_taken, selfie_file_id)
            del awaiting_selfie[user.id]

            teams[user.id]["round"] += 1
            await msg.reply_text("ğŸ“¥ Selfie received! Youâ€™re qualified for the next round ğŸ‰")
            await send_question(update, context)
        else:
            await msg.reply_text("âš ï¸ Please upload a *photo* of your team to continue.")
        return

    # otherwise expecting an integer answer
    text = msg.text.strip() if msg.text else ""
    if not text.isdigit():
        await msg.reply_text("â— Please send only a number as your answer.")
        return

    answer = int(text)
    correct_ans = teams[user.id]["answer"]
    round_num = teams[user.id]["round"]

    if answer == correct_ans:
        await msg.reply_text(
            f"âœ… Correct! Now send a *selfie* of your team in front of the tree #{answer}.",
            parse_mode="Markdown"
        )
        awaiting_selfie[user.id] = {"round": round_num, "answer": answer}
    else:
        await msg.reply_text("âŒ Wrong answer! Youâ€™re disqualified.")
        save_result(user.id, user.username, round_num, False, 0)
        disqualified.add(user.id)
        if user.id in teams:
            del teams[user.id]

# ==========================
# LEADERBOARD (ADMIN ONLY)
# ==========================
import re

def escape_markdown(text):
    """Escape Telegram Markdown special characters"""
    return re.sub(r'([_*[\]()~`>#+\-=|{}.!])', r'\\\1', str(text))

async def leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if str(user.username) != ADMIN_USERNAME:  # fixed ID comparison
        await update.message.reply_text("ğŸš« Youâ€™re not authorized to view the leaderboard.")
        return

    try:
        df = pd.read_csv(RESULTS_FILE)
    except FileNotFoundError:
        await update.message.reply_text("No results yet.")
        return

    correct_df = df[df["correct"] == True]
    if correct_df.empty:
        await update.message.reply_text("No correct submissions yet.")
        return

    summary = correct_df.groupby("username")["round"].max().reset_index()
    summary = summary.sort_values(by="round", ascending=False).head(10)  # ğŸ‘ˆ show only top 10

    msg = "ğŸ† *Top 10 Leaderboard*\n\n"
    for i, row in summary.iterrows():
        msg += f"{i+1}. {row['username']}: Round {int(row['round'])}\n"


    await update.message.reply_text(msg, parse_mode="MarkdownV2")
# ==========================
# HEARTBEAT FUNCTION
# ==========================
async def heartbeat():
    while True:
        print("â³ Bot heartbeat...")  # Keeps Render active
        await asyncio.sleep(600)  # every 10 minutes

def start_heartbeat(loop):
    asyncio.set_event_loop(loop)
    loop.run_until_complete(heartbeat())

# ==========================
# MAIN
# ==========================
if __name__ == "__main__":
    app = ApplicationBuilder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("leaderboard", leaderboard))
    app.add_handler(MessageHandler(filters.ALL & (~filters.COMMAND), handle_message))
    loop = asyncio.new_event_loop()
    t = threading.Thread(target=start_heartbeat, args=(loop,), daemon=True)
    t.start()
    print("ğŸ¤– Bot running...")
    app.run_polling()
